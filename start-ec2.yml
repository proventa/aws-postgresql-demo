- name: Create Fedora CoreOS and its needed resources
  hosts: localhost
  connection: local
  gather_facts: false
  vars:
    num_of_instances: 3
    inventory_file: /root/aws-postgresql-demo/ansible/hosts
    ec2_tags:
      cluster: etcd
    ssh_priv_key: /root/aws-postgresql-demo/keys/postgres-demo
  tasks:
    - name: Ensure that VPC exists
      amazon.aws.ec2_vpc_net:
        name: postgres_demo_vpc
        cidr_block: 10.0.0.0/16
        region: eu-central-1
        tags:
          env: demo
        state: present
      register: vpc_net

    - name: Ensure that an internet gateway for the VPC exists
      amazon.aws.ec2_vpc_igw:
        vpc_id: "{{ vpc_net.vpc.id }}"
        state: present
        region: eu-central-1
        tags:
          env: demo
      register: igw

    - name: Ensure that the subnet for etcd in the VPC exists
      amazon.aws.ec2_vpc_subnet:
        state: present
        vpc_id: "{{ vpc_net.vpc.id }}"
        cidr: 10.0.0.0/16
        map_public: true
        tags:
          Name: etcd-subnet
      register: etcd_subnet

    - name: Ensure that the route table for the VPC exists # So that the subnet can access and be accessed from the internet
      amazon.aws.ec2_vpc_route_table:
        vpc_id: "{{ vpc_net.vpc.id }}"
        region: eu-central-1
        tags:
          env: demo
        subnets:
          - "{{ etcd_subnet.subnet.id }}"
        routes:
          - dest: 0.0.0.0/0
            gateway_id: "{{ igw.gateway_id }}"
          - dest: ::/0
            gateway_id: "{{ igw.gateway_id }}"
      register: public_route_table

    - name: Ensure that the security group exists
      amazon.aws.ec2_security_group:
        name: "Postgres Demo SG"
        description: "Security group for Postgres Demo"
        vpc_id: "{{ vpc_net.vpc.id }}"
        region: eu-central-1
        rules:
          - proto: tcp
            ports:
              - 22
            cidr_ip: "0.0.0.0/0"
          - proto: all
            from_port: 0
            to_port: 65535
            cidr_ip: "10.0.0.0/16"
        tags:
          env: demo
        state: present
      register: sg

    - name: create key pair using key_material obtained using 'file' lookup plugin
      amazon.aws.ec2_key:
        name: postgres-demo
        key_material: "{{ lookup('file', '/root/aws-postgresql-demo/keys/postgres-demo.pub') }}"
      register: key_pair

    - name: Prepare TLS Certs for HTTPS etcd
      ansible.builtin.shell: $PWD/gen-root-ca.sh

    - name: Create a new etcd discovery service cluster
      ansible.builtin.shell: curl https://discovery.etcd.io/new?size=3 > etcd-discovery-cluster.txt

    - name: Prepare ignition file # Converting Butane to Ignition
      ansible.builtin.shell: podman run --interactive --rm --security-opt label=disable --volume ${PWD}:/pwd --workdir /pwd quay.io/coreos/butane:release -d /pwd --pretty --strict etcd.butane.yml > etcd.ign

    - name: Start Fedora CoreOS instances
      amazon.aws.ec2_instance:
        instance_type: t2.micro
        image_id: ami-01616b3a6ec881521 # Fedora CoreOS
        count: "{{ num_of_instances }}"
        region: eu-central-1
        network:
          assign_public_ip: true
        security_group: "{{ sg.group_name }}"
        vpc_subnet_id: "{{ etcd_subnet.subnet.id }}"
        state: running
        key_name: "{{ key_pair.key.name }}"
        tags: "{{ ec2_tags }}"
        user_data: '{{ lookup("file", "/root/aws-postgresql-demo/etcd.ign")|string }}'
      register: ec2_instance

    - name: Ensure the group [ "{{ ec2_tags.cluster }}" ] exists in the inventory file
      ansible.builtin.lineinfile:
        path: "{{ inventory_file }}"
        line: "[{{ ec2_tags.cluster }}]"
        state: present
      
    - name: Add the insance ID to the group 'etcd' in the inventory file
      ansible.builtin.lineinfile:
        path: "{{ inventory_file }}"
        line: "{{ item.instance_id }} ansible_host={{ item.public_ip_address }} ansible_ssh_private_key_file={{ ssh_priv_key }} ansible_user=core"
        insertafter: "{{ ec2_tags.cluster }}"
        state: present
      with_items: "{{ ec2_instance.instances }}"
